/*
 * ============================ WARNING ============================
 * ==== This is an autogenerated file.                          ====
 * ==== Any changes to this file will be lost when recompiling. ====
 * =================================================================
 *
 * This file contains support functions for the ODrive ASCII protocol.
 *
 * TODO: might generalize this as an approach to runtime introspection.
 */

#include <fibre/introspection.hpp>

#pragma GCC push_options
#pragma GCC optimize ("s")


template<typename T>
struct ODriveTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::get_vbus_voltage(std::declval<T*>()))*)(&res) = ODriveIntf::get_vbus_voltage(ptr); break;
            case 1: *(decltype(ODriveIntf::get_ibus(std::declval<T*>()))*)(&res) = ODriveIntf::get_ibus(ptr); break;
            case 2: *(decltype(ODriveIntf::get_serial_number(std::declval<T*>()))*)(&res) = ODriveIntf::get_serial_number(ptr); break;
            case 3: *(decltype(ODriveIntf::get_hw_version_major(std::declval<T*>()))*)(&res) = ODriveIntf::get_hw_version_major(ptr); break;
            case 4: *(decltype(ODriveIntf::get_hw_version_minor(std::declval<T*>()))*)(&res) = ODriveIntf::get_hw_version_minor(ptr); break;
            case 5: *(decltype(ODriveIntf::get_hw_version_variant(std::declval<T*>()))*)(&res) = ODriveIntf::get_hw_version_variant(ptr); break;
            case 6: *(decltype(ODriveIntf::get_fw_version_major(std::declval<T*>()))*)(&res) = ODriveIntf::get_fw_version_major(ptr); break;
            case 7: *(decltype(ODriveIntf::get_fw_version_minor(std::declval<T*>()))*)(&res) = ODriveIntf::get_fw_version_minor(ptr); break;
            case 8: *(decltype(ODriveIntf::get_fw_version_revision(std::declval<T*>()))*)(&res) = ODriveIntf::get_fw_version_revision(ptr); break;
            case 9: *(decltype(ODriveIntf::get_fw_version_unreleased(std::declval<T*>()))*)(&res) = ODriveIntf::get_fw_version_unreleased(ptr); break;
            case 10: *(decltype(ODriveIntf::get_brake_resistor_armed(std::declval<T*>()))*)(&res) = ODriveIntf::get_brake_resistor_armed(ptr); break;
            case 11: *(decltype(ODriveIntf::get_brake_resistor_saturated(std::declval<T*>()))*)(&res) = ODriveIntf::get_brake_resistor_saturated(ptr); break;
            case 12: *(decltype(ODriveIntf::get_system_stats(std::declval<T*>()))*)(&res) = ODriveIntf::get_system_stats(ptr); break;
            case 13: *(decltype(ODriveIntf::get_config(std::declval<T*>()))*)(&res) = ODriveIntf::get_config(ptr); break;
            case 14: *(decltype(ODriveIntf::get_user_config_loaded(std::declval<T*>()))*)(&res) = ODriveIntf::get_user_config_loaded(ptr); break;
            case 15: *(decltype(ODriveIntf::get_axis0(std::declval<T*>()))*)(&res) = ODriveIntf::get_axis0(ptr); break;
            case 16: *(decltype(ODriveIntf::get_axis1(std::declval<T*>()))*)(&res) = ODriveIntf::get_axis1(ptr); break;
            case 17: *(decltype(ODriveIntf::get_can(std::declval<T*>()))*)(&res) = ODriveIntf::get_can(ptr); break;
            case 18: *(decltype(ODriveIntf::get_test_property(std::declval<T*>()))*)(&res) = ODriveIntf::get_test_property(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveCanTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveCanTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::CanIntf::get_error(std::declval<T*>()))*)(&res) = ODriveIntf::CanIntf::get_error(ptr); break;
            case 1: *(decltype(ODriveIntf::CanIntf::get_config(std::declval<T*>()))*)(&res) = ODriveIntf::CanIntf::get_config(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveEndpointTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveEndpointTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::EndpointIntf::get_endpoint(std::declval<T*>()))*)(&res) = ODriveIntf::EndpointIntf::get_endpoint(ptr); break;
            case 1: *(decltype(ODriveIntf::EndpointIntf::get_min(std::declval<T*>()))*)(&res) = ODriveIntf::EndpointIntf::get_min(ptr); break;
            case 2: *(decltype(ODriveIntf::EndpointIntf::get_max(std::declval<T*>()))*)(&res) = ODriveIntf::EndpointIntf::get_max(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveAxisTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveAxisTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::AxisIntf::get_error(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_error(ptr); break;
            case 1: *(decltype(ODriveIntf::AxisIntf::get_step_dir_active(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_step_dir_active(ptr); break;
            case 2: *(decltype(ODriveIntf::AxisIntf::get_current_state(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_current_state(ptr); break;
            case 3: *(decltype(ODriveIntf::AxisIntf::get_requested_state(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_requested_state(ptr); break;
            case 4: *(decltype(ODriveIntf::AxisIntf::get_loop_counter(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_loop_counter(ptr); break;
            case 5: *(decltype(ODriveIntf::AxisIntf::get_lockin_state(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_lockin_state(ptr); break;
            case 6: *(decltype(ODriveIntf::AxisIntf::get_is_homed(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_is_homed(ptr); break;
            case 7: *(decltype(ODriveIntf::AxisIntf::get_config(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_config(ptr); break;
            case 8: *(decltype(ODriveIntf::AxisIntf::get_motor(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_motor(ptr); break;
            case 9: *(decltype(ODriveIntf::AxisIntf::get_controller(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_controller(ptr); break;
            case 10: *(decltype(ODriveIntf::AxisIntf::get_encoder(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_encoder(ptr); break;
            case 11: *(decltype(ODriveIntf::AxisIntf::get_sensorless_estimator(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_sensorless_estimator(ptr); break;
            case 12: *(decltype(ODriveIntf::AxisIntf::get_trap_traj(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_trap_traj(ptr); break;
            case 13: *(decltype(ODriveIntf::AxisIntf::get_min_endstop(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_min_endstop(ptr); break;
            case 14: *(decltype(ODriveIntf::AxisIntf::get_max_endstop(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_max_endstop(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveAxisLockinConfigTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveAxisLockinConfigTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::AxisIntf::LockinConfigIntf::get_current(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::LockinConfigIntf::get_current(ptr); break;
            case 1: *(decltype(ODriveIntf::AxisIntf::LockinConfigIntf::get_ramp_time(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::LockinConfigIntf::get_ramp_time(ptr); break;
            case 2: *(decltype(ODriveIntf::AxisIntf::LockinConfigIntf::get_ramp_distance(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::LockinConfigIntf::get_ramp_distance(ptr); break;
            case 3: *(decltype(ODriveIntf::AxisIntf::LockinConfigIntf::get_accel(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::LockinConfigIntf::get_accel(ptr); break;
            case 4: *(decltype(ODriveIntf::AxisIntf::LockinConfigIntf::get_vel(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::LockinConfigIntf::get_vel(ptr); break;
            case 5: *(decltype(ODriveIntf::AxisIntf::LockinConfigIntf::get_finish_distance(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::LockinConfigIntf::get_finish_distance(ptr); break;
            case 6: *(decltype(ODriveIntf::AxisIntf::LockinConfigIntf::get_finish_on_vel(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::LockinConfigIntf::get_finish_on_vel(ptr); break;
            case 7: *(decltype(ODriveIntf::AxisIntf::LockinConfigIntf::get_finish_on_distance(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::LockinConfigIntf::get_finish_on_distance(ptr); break;
            case 8: *(decltype(ODriveIntf::AxisIntf::LockinConfigIntf::get_finish_on_enc_idx(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::LockinConfigIntf::get_finish_on_enc_idx(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveMotorTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveMotorTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::MotorIntf::get_error(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_error(ptr); break;
            case 1: *(decltype(ODriveIntf::MotorIntf::get_armed_state(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_armed_state(ptr); break;
            case 2: *(decltype(ODriveIntf::MotorIntf::get_is_calibrated(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_is_calibrated(ptr); break;
            case 3: *(decltype(ODriveIntf::MotorIntf::get_current_meas_phB(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_current_meas_phB(ptr); break;
            case 4: *(decltype(ODriveIntf::MotorIntf::get_current_meas_phC(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_current_meas_phC(ptr); break;
            case 5: *(decltype(ODriveIntf::MotorIntf::get_DC_calib_phB(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_DC_calib_phB(ptr); break;
            case 6: *(decltype(ODriveIntf::MotorIntf::get_DC_calib_phC(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_DC_calib_phC(ptr); break;
            case 7: *(decltype(ODriveIntf::MotorIntf::get_phase_current_rev_gain(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_phase_current_rev_gain(ptr); break;
            case 8: *(decltype(ODriveIntf::MotorIntf::get_thermal_current_lim(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_thermal_current_lim(ptr); break;
            case 9: *(decltype(ODriveIntf::MotorIntf::get_inverter_temp(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_inverter_temp(ptr); break;
            case 10: *(decltype(ODriveIntf::MotorIntf::get_current_control(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_current_control(ptr); break;
            case 11: *(decltype(ODriveIntf::MotorIntf::get_gate_driver(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_gate_driver(ptr); break;
            case 12: *(decltype(ODriveIntf::MotorIntf::get_timing_log(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_timing_log(ptr); break;
            case 13: *(decltype(ODriveIntf::MotorIntf::get_config(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_config(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveControllerTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveControllerTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::ControllerIntf::get_error(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::get_error(ptr); break;
            case 1: *(decltype(ODriveIntf::ControllerIntf::get_input_pos(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::get_input_pos(ptr); break;
            case 2: *(decltype(ODriveIntf::ControllerIntf::get_input_vel(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::get_input_vel(ptr); break;
            case 3: *(decltype(ODriveIntf::ControllerIntf::get_input_torque(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::get_input_torque(ptr); break;
            case 4: *(decltype(ODriveIntf::ControllerIntf::get_pos_setpoint(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::get_pos_setpoint(ptr); break;
            case 5: *(decltype(ODriveIntf::ControllerIntf::get_vel_setpoint(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::get_vel_setpoint(ptr); break;
            case 6: *(decltype(ODriveIntf::ControllerIntf::get_torque_setpoint(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::get_torque_setpoint(ptr); break;
            case 7: *(decltype(ODriveIntf::ControllerIntf::get_trajectory_done(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::get_trajectory_done(ptr); break;
            case 8: *(decltype(ODriveIntf::ControllerIntf::get_vel_integrator_torque(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::get_vel_integrator_torque(ptr); break;
            case 9: *(decltype(ODriveIntf::ControllerIntf::get_anticogging_valid(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::get_anticogging_valid(ptr); break;
            case 10: *(decltype(ODriveIntf::ControllerIntf::get_config(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::get_config(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveEncoderTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveEncoderTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::EncoderIntf::get_error(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_error(ptr); break;
            case 1: *(decltype(ODriveIntf::EncoderIntf::get_is_ready(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_is_ready(ptr); break;
            case 2: *(decltype(ODriveIntf::EncoderIntf::get_index_found(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_index_found(ptr); break;
            case 3: *(decltype(ODriveIntf::EncoderIntf::get_shadow_count(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_shadow_count(ptr); break;
            case 4: *(decltype(ODriveIntf::EncoderIntf::get_count_in_cpr(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_count_in_cpr(ptr); break;
            case 5: *(decltype(ODriveIntf::EncoderIntf::get_interpolation(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_interpolation(ptr); break;
            case 6: *(decltype(ODriveIntf::EncoderIntf::get_phase(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_phase(ptr); break;
            case 7: *(decltype(ODriveIntf::EncoderIntf::get_pos_estimate(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_pos_estimate(ptr); break;
            case 8: *(decltype(ODriveIntf::EncoderIntf::get_pos_cpr(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_pos_cpr(ptr); break;
            case 9: *(decltype(ODriveIntf::EncoderIntf::get_hall_state(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_hall_state(ptr); break;
            case 10: *(decltype(ODriveIntf::EncoderIntf::get_vel_estimate(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_vel_estimate(ptr); break;
            case 11: *(decltype(ODriveIntf::EncoderIntf::get_calib_scan_response(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_calib_scan_response(ptr); break;
            case 12: *(decltype(ODriveIntf::EncoderIntf::get_pos_abs(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_pos_abs(ptr); break;
            case 13: *(decltype(ODriveIntf::EncoderIntf::get_spi_error_rate(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_spi_error_rate(ptr); break;
            case 14: *(decltype(ODriveIntf::EncoderIntf::get_config(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_config(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveSensorlessEstimatorTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveSensorlessEstimatorTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::SensorlessEstimatorIntf::get_error(std::declval<T*>()))*)(&res) = ODriveIntf::SensorlessEstimatorIntf::get_error(ptr); break;
            case 1: *(decltype(ODriveIntf::SensorlessEstimatorIntf::get_phase(std::declval<T*>()))*)(&res) = ODriveIntf::SensorlessEstimatorIntf::get_phase(ptr); break;
            case 2: *(decltype(ODriveIntf::SensorlessEstimatorIntf::get_pll_pos(std::declval<T*>()))*)(&res) = ODriveIntf::SensorlessEstimatorIntf::get_pll_pos(ptr); break;
            case 3: *(decltype(ODriveIntf::SensorlessEstimatorIntf::get_vel_estimate(std::declval<T*>()))*)(&res) = ODriveIntf::SensorlessEstimatorIntf::get_vel_estimate(ptr); break;
            case 4: *(decltype(ODriveIntf::SensorlessEstimatorIntf::get_config(std::declval<T*>()))*)(&res) = ODriveIntf::SensorlessEstimatorIntf::get_config(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveTrapezoidalTrajectoryTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveTrapezoidalTrajectoryTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::TrapezoidalTrajectoryIntf::get_config(std::declval<T*>()))*)(&res) = ODriveIntf::TrapezoidalTrajectoryIntf::get_config(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveEndstopTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveEndstopTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::EndstopIntf::get_endstop_state(std::declval<T*>()))*)(&res) = ODriveIntf::EndstopIntf::get_endstop_state(ptr); break;
            case 1: *(decltype(ODriveIntf::EndstopIntf::get_config(std::declval<T*>()))*)(&res) = ODriveIntf::EndstopIntf::get_config(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveSystemStatsTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveSystemStatsTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::SystemStatsIntf::get_uptime(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_uptime(ptr); break;
            case 1: *(decltype(ODriveIntf::SystemStatsIntf::get_min_heap_space(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_min_heap_space(ptr); break;
            case 2: *(decltype(ODriveIntf::SystemStatsIntf::get_min_stack_space_axis0(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_min_stack_space_axis0(ptr); break;
            case 3: *(decltype(ODriveIntf::SystemStatsIntf::get_min_stack_space_axis1(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_min_stack_space_axis1(ptr); break;
            case 4: *(decltype(ODriveIntf::SystemStatsIntf::get_min_stack_space_comms(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_min_stack_space_comms(ptr); break;
            case 5: *(decltype(ODriveIntf::SystemStatsIntf::get_min_stack_space_usb(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_min_stack_space_usb(ptr); break;
            case 6: *(decltype(ODriveIntf::SystemStatsIntf::get_min_stack_space_uart(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_min_stack_space_uart(ptr); break;
            case 7: *(decltype(ODriveIntf::SystemStatsIntf::get_min_stack_space_can(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_min_stack_space_can(ptr); break;
            case 8: *(decltype(ODriveIntf::SystemStatsIntf::get_min_stack_space_usb_irq(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_min_stack_space_usb_irq(ptr); break;
            case 9: *(decltype(ODriveIntf::SystemStatsIntf::get_min_stack_space_startup(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_min_stack_space_startup(ptr); break;
            case 10: *(decltype(ODriveIntf::SystemStatsIntf::get_stack_usage_axis0(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_stack_usage_axis0(ptr); break;
            case 11: *(decltype(ODriveIntf::SystemStatsIntf::get_stack_usage_axis1(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_stack_usage_axis1(ptr); break;
            case 12: *(decltype(ODriveIntf::SystemStatsIntf::get_stack_usage_comms(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_stack_usage_comms(ptr); break;
            case 13: *(decltype(ODriveIntf::SystemStatsIntf::get_stack_usage_usb(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_stack_usage_usb(ptr); break;
            case 14: *(decltype(ODriveIntf::SystemStatsIntf::get_stack_usage_uart(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_stack_usage_uart(ptr); break;
            case 15: *(decltype(ODriveIntf::SystemStatsIntf::get_stack_usage_usb_irq(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_stack_usage_usb_irq(ptr); break;
            case 16: *(decltype(ODriveIntf::SystemStatsIntf::get_stack_usage_startup(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_stack_usage_startup(ptr); break;
            case 17: *(decltype(ODriveIntf::SystemStatsIntf::get_stack_usage_can(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_stack_usage_can(ptr); break;
            case 18: *(decltype(ODriveIntf::SystemStatsIntf::get_usb(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_usb(ptr); break;
            case 19: *(decltype(ODriveIntf::SystemStatsIntf::get_i2c(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_i2c(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveSystemStatsUsbTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveSystemStatsUsbTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::SystemStatsIntf::UsbIntf::get_rx_cnt(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::UsbIntf::get_rx_cnt(ptr); break;
            case 1: *(decltype(ODriveIntf::SystemStatsIntf::UsbIntf::get_tx_cnt(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::UsbIntf::get_tx_cnt(ptr); break;
            case 2: *(decltype(ODriveIntf::SystemStatsIntf::UsbIntf::get_tx_overrun_cnt(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::UsbIntf::get_tx_overrun_cnt(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveSystemStatsI2CTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveSystemStatsI2CTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::SystemStatsIntf::I2CIntf::get_addr(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::I2CIntf::get_addr(ptr); break;
            case 1: *(decltype(ODriveIntf::SystemStatsIntf::I2CIntf::get_addr_match_cnt(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::I2CIntf::get_addr_match_cnt(ptr); break;
            case 2: *(decltype(ODriveIntf::SystemStatsIntf::I2CIntf::get_rx_cnt(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::I2CIntf::get_rx_cnt(ptr); break;
            case 3: *(decltype(ODriveIntf::SystemStatsIntf::I2CIntf::get_error_cnt(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::I2CIntf::get_error_cnt(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveConfigTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveConfigTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::ConfigIntf::get_enable_uart(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_enable_uart(ptr); break;
            case 1: *(decltype(ODriveIntf::ConfigIntf::get_uart_baudrate(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_uart_baudrate(ptr); break;
            case 2: *(decltype(ODriveIntf::ConfigIntf::get_enable_i2c_instead_of_can(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_enable_i2c_instead_of_can(ptr); break;
            case 3: *(decltype(ODriveIntf::ConfigIntf::get_enable_ascii_protocol_on_usb(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_enable_ascii_protocol_on_usb(ptr); break;
            case 4: *(decltype(ODriveIntf::ConfigIntf::get_max_regen_current(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_max_regen_current(ptr); break;
            case 5: *(decltype(ODriveIntf::ConfigIntf::get_brake_resistance(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_brake_resistance(ptr); break;
            case 6: *(decltype(ODriveIntf::ConfigIntf::get_dc_bus_undervoltage_trip_level(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_dc_bus_undervoltage_trip_level(ptr); break;
            case 7: *(decltype(ODriveIntf::ConfigIntf::get_dc_bus_overvoltage_trip_level(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_dc_bus_overvoltage_trip_level(ptr); break;
            case 8: *(decltype(ODriveIntf::ConfigIntf::get_enable_dc_bus_overvoltage_ramp(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_enable_dc_bus_overvoltage_ramp(ptr); break;
            case 9: *(decltype(ODriveIntf::ConfigIntf::get_dc_bus_overvoltage_ramp_start(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_dc_bus_overvoltage_ramp_start(ptr); break;
            case 10: *(decltype(ODriveIntf::ConfigIntf::get_dc_bus_overvoltage_ramp_end(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_dc_bus_overvoltage_ramp_end(ptr); break;
            case 11: *(decltype(ODriveIntf::ConfigIntf::get_dc_max_positive_current(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_dc_max_positive_current(ptr); break;
            case 12: *(decltype(ODriveIntf::ConfigIntf::get_dc_max_negative_current(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_dc_max_negative_current(ptr); break;
            case 13: *(decltype(ODriveIntf::ConfigIntf::get_gpio1_pwm_mapping(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_gpio1_pwm_mapping(ptr); break;
            case 14: *(decltype(ODriveIntf::ConfigIntf::get_gpio2_pwm_mapping(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_gpio2_pwm_mapping(ptr); break;
            case 15: *(decltype(ODriveIntf::ConfigIntf::get_gpio3_pwm_mapping(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_gpio3_pwm_mapping(ptr); break;
            case 16: *(decltype(ODriveIntf::ConfigIntf::get_gpio4_pwm_mapping(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_gpio4_pwm_mapping(ptr); break;
            case 17: *(decltype(ODriveIntf::ConfigIntf::get_gpio3_analog_mapping(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_gpio3_analog_mapping(ptr); break;
            case 18: *(decltype(ODriveIntf::ConfigIntf::get_gpio4_analog_mapping(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_gpio4_analog_mapping(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveCanConfigTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveCanConfigTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::CanIntf::ConfigIntf::get_baud_rate(std::declval<T*>()))*)(&res) = ODriveIntf::CanIntf::ConfigIntf::get_baud_rate(ptr); break;
            case 1: *(decltype(ODriveIntf::CanIntf::ConfigIntf::get_protocol(std::declval<T*>()))*)(&res) = ODriveIntf::CanIntf::ConfigIntf::get_protocol(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveAxisConfigTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveAxisConfigTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_startup_motor_calibration(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_startup_motor_calibration(ptr); break;
            case 1: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_startup_encoder_index_search(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_startup_encoder_index_search(ptr); break;
            case 2: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_startup_encoder_offset_calibration(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_startup_encoder_offset_calibration(ptr); break;
            case 3: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_startup_closed_loop_control(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_startup_closed_loop_control(ptr); break;
            case 4: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_startup_sensorless_control(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_startup_sensorless_control(ptr); break;
            case 5: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_startup_homing(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_startup_homing(ptr); break;
            case 6: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_enable_step_dir(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_enable_step_dir(ptr); break;
            case 7: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_step_dir_always_on(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_step_dir_always_on(ptr); break;
            case 8: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_use_enable_pin(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_use_enable_pin(ptr); break;
            case 9: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_enable_pin_active_low(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_enable_pin_active_low(ptr); break;
            case 10: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_counts_per_step(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_counts_per_step(ptr); break;
            case 11: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_watchdog_timeout(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_watchdog_timeout(ptr); break;
            case 12: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_enable_watchdog(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_enable_watchdog(ptr); break;
            case 13: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_step_gpio_pin(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_step_gpio_pin(ptr); break;
            case 14: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_dir_gpio_pin(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_dir_gpio_pin(ptr); break;
            case 15: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_en_gpio_pin(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_en_gpio_pin(ptr); break;
            case 16: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_calibration_lockin(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_calibration_lockin(ptr); break;
            case 17: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_sensorless_ramp(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_sensorless_ramp(ptr); break;
            case 18: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_general_lockin(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_general_lockin(ptr); break;
            case 19: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_can_node_id(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_can_node_id(ptr); break;
            case 20: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_can_node_id_extended(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_can_node_id_extended(ptr); break;
            case 21: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_can_heartbeat_rate_ms(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_can_heartbeat_rate_ms(ptr); break;

        }
        return res;
    }
};

template<typename T>
struct ODriveAxisConfigCalibrationLockinTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveAxisConfigCalibrationLockinTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_current(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_current(ptr); break;
            case 1: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_ramp_time(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_ramp_time(ptr); break;
            case 2: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_ramp_distance(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_ramp_distance(ptr); break;
            case 3: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_accel(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_accel(ptr); break;
            case 4: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_vel(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_vel(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveMotorCurrentControlTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveMotorCurrentControlTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_p_gain(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_p_gain(ptr); break;
            case 1: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_i_gain(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_i_gain(ptr); break;
            case 2: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_v_current_control_integral_d(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_v_current_control_integral_d(ptr); break;
            case 3: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_v_current_control_integral_q(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_v_current_control_integral_q(ptr); break;
            case 4: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_Ibus(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_Ibus(ptr); break;
            case 5: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_final_v_alpha(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_final_v_alpha(ptr); break;
            case 6: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_final_v_beta(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_final_v_beta(ptr); break;
            case 7: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_Id_setpoint(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_Id_setpoint(ptr); break;
            case 8: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_Iq_setpoint(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_Iq_setpoint(ptr); break;
            case 9: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_Iq_measured(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_Iq_measured(ptr); break;
            case 10: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_Id_measured(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_Id_measured(ptr); break;
            case 11: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_I_measured_report_filter_k(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_I_measured_report_filter_k(ptr); break;
            case 12: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_max_allowed_current(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_max_allowed_current(ptr); break;
            case 13: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_overcurrent_trip_level(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_overcurrent_trip_level(ptr); break;
            case 14: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_acim_rotor_flux(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_acim_rotor_flux(ptr); break;
            case 15: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_async_phase_vel(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_async_phase_vel(ptr); break;
            case 16: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_async_phase_offset(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_async_phase_offset(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveMotorGateDriverTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveMotorGateDriverTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::MotorIntf::GateDriverIntf::get_drv_fault(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::GateDriverIntf::get_drv_fault(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveMotorTimingLogTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveMotorTimingLogTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::MotorIntf::TimingLogIntf::get_general(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::TimingLogIntf::get_general(ptr); break;
            case 1: *(decltype(ODriveIntf::MotorIntf::TimingLogIntf::get_adc_cb_i(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::TimingLogIntf::get_adc_cb_i(ptr); break;
            case 2: *(decltype(ODriveIntf::MotorIntf::TimingLogIntf::get_adc_cb_dc(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::TimingLogIntf::get_adc_cb_dc(ptr); break;
            case 3: *(decltype(ODriveIntf::MotorIntf::TimingLogIntf::get_meas_r(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::TimingLogIntf::get_meas_r(ptr); break;
            case 4: *(decltype(ODriveIntf::MotorIntf::TimingLogIntf::get_meas_l(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::TimingLogIntf::get_meas_l(ptr); break;
            case 5: *(decltype(ODriveIntf::MotorIntf::TimingLogIntf::get_enc_calib(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::TimingLogIntf::get_enc_calib(ptr); break;
            case 6: *(decltype(ODriveIntf::MotorIntf::TimingLogIntf::get_idx_search(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::TimingLogIntf::get_idx_search(ptr); break;
            case 7: *(decltype(ODriveIntf::MotorIntf::TimingLogIntf::get_foc_voltage(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::TimingLogIntf::get_foc_voltage(ptr); break;
            case 8: *(decltype(ODriveIntf::MotorIntf::TimingLogIntf::get_foc_current(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::TimingLogIntf::get_foc_current(ptr); break;
            case 9: *(decltype(ODriveIntf::MotorIntf::TimingLogIntf::get_spi_start(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::TimingLogIntf::get_spi_start(ptr); break;
            case 10: *(decltype(ODriveIntf::MotorIntf::TimingLogIntf::get_sample_now(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::TimingLogIntf::get_sample_now(ptr); break;
            case 11: *(decltype(ODriveIntf::MotorIntf::TimingLogIntf::get_spi_end(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::TimingLogIntf::get_spi_end(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveMotorConfigTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveMotorConfigTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_pre_calibrated(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_pre_calibrated(ptr); break;
            case 1: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_pole_pairs(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_pole_pairs(ptr); break;
            case 2: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_calibration_current(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_calibration_current(ptr); break;
            case 3: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_resistance_calib_max_voltage(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_resistance_calib_max_voltage(ptr); break;
            case 4: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_phase_inductance(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_phase_inductance(ptr); break;
            case 5: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_phase_resistance(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_phase_resistance(ptr); break;
            case 6: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_torque_constant(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_torque_constant(ptr); break;
            case 7: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_direction(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_direction(ptr); break;
            case 8: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_motor_type(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_motor_type(ptr); break;
            case 9: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_current_lim(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_current_lim(ptr); break;
            case 10: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_current_lim_margin(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_current_lim_margin(ptr); break;
            case 11: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_torque_lim(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_torque_lim(ptr); break;
            case 12: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_inverter_temp_limit_lower(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_inverter_temp_limit_lower(ptr); break;
            case 13: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_inverter_temp_limit_upper(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_inverter_temp_limit_upper(ptr); break;
            case 14: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_requested_current_range(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_requested_current_range(ptr); break;
            case 15: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_current_control_bandwidth(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_current_control_bandwidth(ptr); break;
            case 16: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_acim_slip_velocity(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_acim_slip_velocity(ptr); break;
            case 17: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_acim_gain_min_flux(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_acim_gain_min_flux(ptr); break;
            case 18: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_acim_autoflux_min_Id(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_acim_autoflux_min_Id(ptr); break;
            case 19: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_acim_autoflux_enable(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_acim_autoflux_enable(ptr); break;
            case 20: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_acim_autoflux_attack_gain(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_acim_autoflux_attack_gain(ptr); break;
            case 21: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_acim_autoflux_decay_gain(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_acim_autoflux_decay_gain(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveControllerConfigTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveControllerConfigTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_gain_scheduling_width(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_gain_scheduling_width(ptr); break;
            case 1: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_enable_vel_limit(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_enable_vel_limit(ptr); break;
            case 2: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_enable_current_mode_vel_limit(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_enable_current_mode_vel_limit(ptr); break;
            case 3: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_enable_gain_scheduling(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_enable_gain_scheduling(ptr); break;
            case 4: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_enable_overspeed_error(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_enable_overspeed_error(ptr); break;
            case 5: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_control_mode(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_control_mode(ptr); break;
            case 6: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_input_mode(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_input_mode(ptr); break;
            case 7: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_pos_gain(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_pos_gain(ptr); break;
            case 8: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_vel_gain(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_vel_gain(ptr); break;
            case 9: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_vel_integrator_gain(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_vel_integrator_gain(ptr); break;
            case 10: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_vel_limit(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_vel_limit(ptr); break;
            case 11: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_vel_limit_tolerance(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_vel_limit_tolerance(ptr); break;
            case 12: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_vel_ramp_rate(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_vel_ramp_rate(ptr); break;
            case 13: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_torque_ramp_rate(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_torque_ramp_rate(ptr); break;
            case 14: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_homing_speed(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_homing_speed(ptr); break;
            case 15: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_inertia(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_inertia(ptr); break;
            case 16: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_axis_to_mirror(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_axis_to_mirror(ptr); break;
            case 17: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_mirror_ratio(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_mirror_ratio(ptr); break;
            case 18: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_load_encoder_axis(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_load_encoder_axis(ptr); break;
            case 19: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_input_filter_bandwidth(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_input_filter_bandwidth(ptr); break;
            case 20: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_anticogging(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_anticogging(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveControllerConfigAnticoggingTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveControllerConfigAnticoggingTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_index(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_index(ptr); break;
            case 1: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_pre_calibrated(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_pre_calibrated(ptr); break;
            case 2: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_calib_anticogging(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_calib_anticogging(ptr); break;
            case 3: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_calib_pos_threshold(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_calib_pos_threshold(ptr); break;
            case 4: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_calib_vel_threshold(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_calib_vel_threshold(ptr); break;
            case 5: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_cogging_ratio(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_cogging_ratio(ptr); break;
            case 6: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_anticogging_enabled(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_anticogging_enabled(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveEncoderConfigTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveEncoderConfigTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_mode(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_mode(ptr); break;
            case 1: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_use_index(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_use_index(ptr); break;
            case 2: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_find_idx_on_lockin_only(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_find_idx_on_lockin_only(ptr); break;
            case 3: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_abs_spi_cs_gpio_pin(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_abs_spi_cs_gpio_pin(ptr); break;
            case 4: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_zero_count_on_find_idx(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_zero_count_on_find_idx(ptr); break;
            case 5: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_cpr(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_cpr(ptr); break;
            case 6: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_offset(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_offset(ptr); break;
            case 7: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_pre_calibrated(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_pre_calibrated(ptr); break;
            case 8: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_offset_float(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_offset_float(ptr); break;
            case 9: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_enable_phase_interpolation(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_enable_phase_interpolation(ptr); break;
            case 10: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_bandwidth(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_bandwidth(ptr); break;
            case 11: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_calib_range(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_calib_range(ptr); break;
            case 12: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_calib_scan_distance(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_calib_scan_distance(ptr); break;
            case 13: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_calib_scan_omega(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_calib_scan_omega(ptr); break;
            case 14: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_idx_search_unidirectional(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_idx_search_unidirectional(ptr); break;
            case 15: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_ignore_illegal_hall_state(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_ignore_illegal_hall_state(ptr); break;
            case 16: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_sincos_gpio_pin_sin(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_sincos_gpio_pin_sin(ptr); break;
            case 17: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_sincos_gpio_pin_cos(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_sincos_gpio_pin_cos(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveSensorlessEstimatorConfigTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveSensorlessEstimatorConfigTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::SensorlessEstimatorIntf::ConfigIntf::get_observer_gain(std::declval<T*>()))*)(&res) = ODriveIntf::SensorlessEstimatorIntf::ConfigIntf::get_observer_gain(ptr); break;
            case 1: *(decltype(ODriveIntf::SensorlessEstimatorIntf::ConfigIntf::get_pll_bandwidth(std::declval<T*>()))*)(&res) = ODriveIntf::SensorlessEstimatorIntf::ConfigIntf::get_pll_bandwidth(ptr); break;
            case 2: *(decltype(ODriveIntf::SensorlessEstimatorIntf::ConfigIntf::get_pm_flux_linkage(std::declval<T*>()))*)(&res) = ODriveIntf::SensorlessEstimatorIntf::ConfigIntf::get_pm_flux_linkage(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveTrapezoidalTrajectoryConfigTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveTrapezoidalTrajectoryConfigTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::TrapezoidalTrajectoryIntf::ConfigIntf::get_vel_limit(std::declval<T*>()))*)(&res) = ODriveIntf::TrapezoidalTrajectoryIntf::ConfigIntf::get_vel_limit(ptr); break;
            case 1: *(decltype(ODriveIntf::TrapezoidalTrajectoryIntf::ConfigIntf::get_accel_limit(std::declval<T*>()))*)(&res) = ODriveIntf::TrapezoidalTrajectoryIntf::ConfigIntf::get_accel_limit(ptr); break;
            case 2: *(decltype(ODriveIntf::TrapezoidalTrajectoryIntf::ConfigIntf::get_decel_limit(std::declval<T*>()))*)(&res) = ODriveIntf::TrapezoidalTrajectoryIntf::ConfigIntf::get_decel_limit(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveEndstopConfigTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveEndstopConfigTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::EndstopIntf::ConfigIntf::get_gpio_num(std::declval<T*>()))*)(&res) = ODriveIntf::EndstopIntf::ConfigIntf::get_gpio_num(ptr); break;
            case 1: *(decltype(ODriveIntf::EndstopIntf::ConfigIntf::get_enabled(std::declval<T*>()))*)(&res) = ODriveIntf::EndstopIntf::ConfigIntf::get_enabled(ptr); break;
            case 2: *(decltype(ODriveIntf::EndstopIntf::ConfigIntf::get_offset(std::declval<T*>()))*)(&res) = ODriveIntf::EndstopIntf::ConfigIntf::get_offset(ptr); break;
            case 3: *(decltype(ODriveIntf::EndstopIntf::ConfigIntf::get_is_active_high(std::declval<T*>()))*)(&res) = ODriveIntf::EndstopIntf::ConfigIntf::get_is_active_high(ptr); break;
            case 4: *(decltype(ODriveIntf::EndstopIntf::ConfigIntf::get_pullup(std::declval<T*>()))*)(&res) = ODriveIntf::EndstopIntf::ConfigIntf::get_pullup(ptr); break;
            case 5: *(decltype(ODriveIntf::EndstopIntf::ConfigIntf::get_debounce_ms(std::declval<T*>()))*)(&res) = ODriveIntf::EndstopIntf::ConfigIntf::get_debounce_ms(ptr); break;
        }
        return res;
    }
};



template<typename T>
const PropertyInfo ODriveTypeInfo<T>::property_table[] = {
    {"vbus_voltage", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_vbus_voltage(std::declval<T*>()))>>::singleton},
    {"ibus", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_ibus(std::declval<T*>()))>>::singleton},
    {"serial_number", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_serial_number(std::declval<T*>()))>>::singleton},
    {"hw_version_major", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_hw_version_major(std::declval<T*>()))>>::singleton},
    {"hw_version_minor", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_hw_version_minor(std::declval<T*>()))>>::singleton},
    {"hw_version_variant", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_hw_version_variant(std::declval<T*>()))>>::singleton},
    {"fw_version_major", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_fw_version_major(std::declval<T*>()))>>::singleton},
    {"fw_version_minor", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_fw_version_minor(std::declval<T*>()))>>::singleton},
    {"fw_version_revision", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_fw_version_revision(std::declval<T*>()))>>::singleton},
    {"fw_version_unreleased", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_fw_version_unreleased(std::declval<T*>()))>>::singleton},
    {"brake_resistor_armed", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_brake_resistor_armed(std::declval<T*>()))>>::singleton},
    {"brake_resistor_saturated", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_brake_resistor_saturated(std::declval<T*>()))>>::singleton},
    {"system_stats", &ODriveSystemStatsTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_system_stats(std::declval<T*>()))>>::singleton},
    {"config", &ODriveConfigTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_config(std::declval<T*>()))>>::singleton},
    {"user_config_loaded", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_user_config_loaded(std::declval<T*>()))>>::singleton},
    {"axis0", &ODriveAxisTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_axis0(std::declval<T*>()))>>::singleton},
    {"axis1", &ODriveAxisTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_axis1(std::declval<T*>()))>>::singleton},
    {"can", &ODriveCanTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_can(std::declval<T*>()))>>::singleton},
    {"test_property", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_test_property(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveTypeInfo<T> ODriveTypeInfo<T>::singleton{ODriveTypeInfo<T>::property_table, sizeof(ODriveTypeInfo<T>::property_table) / sizeof(ODriveTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveCanTypeInfo<T>::property_table[] = {
    {"error", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::CanIntf::get_error(std::declval<T*>()))>>::singleton},
    {"config", &ODriveCanConfigTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::CanIntf::get_config(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveCanTypeInfo<T> ODriveCanTypeInfo<T>::singleton{ODriveCanTypeInfo<T>::property_table, sizeof(ODriveCanTypeInfo<T>::property_table) / sizeof(ODriveCanTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveEndpointTypeInfo<T>::property_table[] = {
    {"endpoint", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EndpointIntf::get_endpoint(std::declval<T*>()))>>::singleton},
    {"min", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EndpointIntf::get_min(std::declval<T*>()))>>::singleton},
    {"max", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EndpointIntf::get_max(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveEndpointTypeInfo<T> ODriveEndpointTypeInfo<T>::singleton{ODriveEndpointTypeInfo<T>::property_table, sizeof(ODriveEndpointTypeInfo<T>::property_table) / sizeof(ODriveEndpointTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveAxisTypeInfo<T>::property_table[] = {
    {"error", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_error(std::declval<T*>()))>>::singleton},
    {"step_dir_active", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_step_dir_active(std::declval<T*>()))>>::singleton},
    {"current_state", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_current_state(std::declval<T*>()))>>::singleton},
    {"requested_state", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_requested_state(std::declval<T*>()))>>::singleton},
    {"loop_counter", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_loop_counter(std::declval<T*>()))>>::singleton},
    {"lockin_state", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_lockin_state(std::declval<T*>()))>>::singleton},
    {"is_homed", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_is_homed(std::declval<T*>()))>>::singleton},
    {"config", &ODriveAxisConfigTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_config(std::declval<T*>()))>>::singleton},
    {"motor", &ODriveMotorTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_motor(std::declval<T*>()))>>::singleton},
    {"controller", &ODriveControllerTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_controller(std::declval<T*>()))>>::singleton},
    {"encoder", &ODriveEncoderTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_encoder(std::declval<T*>()))>>::singleton},
    {"sensorless_estimator", &ODriveSensorlessEstimatorTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_sensorless_estimator(std::declval<T*>()))>>::singleton},
    {"trap_traj", &ODriveTrapezoidalTrajectoryTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_trap_traj(std::declval<T*>()))>>::singleton},
    {"min_endstop", &ODriveEndstopTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_min_endstop(std::declval<T*>()))>>::singleton},
    {"max_endstop", &ODriveEndstopTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_max_endstop(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveAxisTypeInfo<T> ODriveAxisTypeInfo<T>::singleton{ODriveAxisTypeInfo<T>::property_table, sizeof(ODriveAxisTypeInfo<T>::property_table) / sizeof(ODriveAxisTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveAxisLockinConfigTypeInfo<T>::property_table[] = {
    {"current", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::LockinConfigIntf::get_current(std::declval<T*>()))>>::singleton},
    {"ramp_time", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::LockinConfigIntf::get_ramp_time(std::declval<T*>()))>>::singleton},
    {"ramp_distance", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::LockinConfigIntf::get_ramp_distance(std::declval<T*>()))>>::singleton},
    {"accel", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::LockinConfigIntf::get_accel(std::declval<T*>()))>>::singleton},
    {"vel", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::LockinConfigIntf::get_vel(std::declval<T*>()))>>::singleton},
    {"finish_distance", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::LockinConfigIntf::get_finish_distance(std::declval<T*>()))>>::singleton},
    {"finish_on_vel", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::LockinConfigIntf::get_finish_on_vel(std::declval<T*>()))>>::singleton},
    {"finish_on_distance", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::LockinConfigIntf::get_finish_on_distance(std::declval<T*>()))>>::singleton},
    {"finish_on_enc_idx", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::LockinConfigIntf::get_finish_on_enc_idx(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveAxisLockinConfigTypeInfo<T> ODriveAxisLockinConfigTypeInfo<T>::singleton{ODriveAxisLockinConfigTypeInfo<T>::property_table, sizeof(ODriveAxisLockinConfigTypeInfo<T>::property_table) / sizeof(ODriveAxisLockinConfigTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveMotorTypeInfo<T>::property_table[] = {
    {"error", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_error(std::declval<T*>()))>>::singleton},
    {"armed_state", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_armed_state(std::declval<T*>()))>>::singleton},
    {"is_calibrated", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_is_calibrated(std::declval<T*>()))>>::singleton},
    {"current_meas_phB", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_current_meas_phB(std::declval<T*>()))>>::singleton},
    {"current_meas_phC", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_current_meas_phC(std::declval<T*>()))>>::singleton},
    {"DC_calib_phB", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_DC_calib_phB(std::declval<T*>()))>>::singleton},
    {"DC_calib_phC", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_DC_calib_phC(std::declval<T*>()))>>::singleton},
    {"phase_current_rev_gain", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_phase_current_rev_gain(std::declval<T*>()))>>::singleton},
    {"thermal_current_lim", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_thermal_current_lim(std::declval<T*>()))>>::singleton},
    {"inverter_temp", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_inverter_temp(std::declval<T*>()))>>::singleton},
    {"current_control", &ODriveMotorCurrentControlTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_current_control(std::declval<T*>()))>>::singleton},
    {"gate_driver", &ODriveMotorGateDriverTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_gate_driver(std::declval<T*>()))>>::singleton},
    {"timing_log", &ODriveMotorTimingLogTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_timing_log(std::declval<T*>()))>>::singleton},
    {"config", &ODriveMotorConfigTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_config(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveMotorTypeInfo<T> ODriveMotorTypeInfo<T>::singleton{ODriveMotorTypeInfo<T>::property_table, sizeof(ODriveMotorTypeInfo<T>::property_table) / sizeof(ODriveMotorTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveControllerTypeInfo<T>::property_table[] = {
    {"error", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::get_error(std::declval<T*>()))>>::singleton},
    {"input_pos", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::get_input_pos(std::declval<T*>()))>>::singleton},
    {"input_vel", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::get_input_vel(std::declval<T*>()))>>::singleton},
    {"input_torque", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::get_input_torque(std::declval<T*>()))>>::singleton},
    {"pos_setpoint", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::get_pos_setpoint(std::declval<T*>()))>>::singleton},
    {"vel_setpoint", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::get_vel_setpoint(std::declval<T*>()))>>::singleton},
    {"torque_setpoint", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::get_torque_setpoint(std::declval<T*>()))>>::singleton},
    {"trajectory_done", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::get_trajectory_done(std::declval<T*>()))>>::singleton},
    {"vel_integrator_torque", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::get_vel_integrator_torque(std::declval<T*>()))>>::singleton},
    {"anticogging_valid", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::get_anticogging_valid(std::declval<T*>()))>>::singleton},
    {"config", &ODriveControllerConfigTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::get_config(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveControllerTypeInfo<T> ODriveControllerTypeInfo<T>::singleton{ODriveControllerTypeInfo<T>::property_table, sizeof(ODriveControllerTypeInfo<T>::property_table) / sizeof(ODriveControllerTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveEncoderTypeInfo<T>::property_table[] = {
    {"error", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_error(std::declval<T*>()))>>::singleton},
    {"is_ready", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_is_ready(std::declval<T*>()))>>::singleton},
    {"index_found", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_index_found(std::declval<T*>()))>>::singleton},
    {"shadow_count", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_shadow_count(std::declval<T*>()))>>::singleton},
    {"count_in_cpr", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_count_in_cpr(std::declval<T*>()))>>::singleton},
    {"interpolation", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_interpolation(std::declval<T*>()))>>::singleton},
    {"phase", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_phase(std::declval<T*>()))>>::singleton},
    {"pos_estimate", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_pos_estimate(std::declval<T*>()))>>::singleton},
    {"pos_cpr", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_pos_cpr(std::declval<T*>()))>>::singleton},
    {"hall_state", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_hall_state(std::declval<T*>()))>>::singleton},
    {"vel_estimate", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_vel_estimate(std::declval<T*>()))>>::singleton},
    {"calib_scan_response", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_calib_scan_response(std::declval<T*>()))>>::singleton},
    {"pos_abs", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_pos_abs(std::declval<T*>()))>>::singleton},
    {"spi_error_rate", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_spi_error_rate(std::declval<T*>()))>>::singleton},
    {"config", &ODriveEncoderConfigTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_config(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveEncoderTypeInfo<T> ODriveEncoderTypeInfo<T>::singleton{ODriveEncoderTypeInfo<T>::property_table, sizeof(ODriveEncoderTypeInfo<T>::property_table) / sizeof(ODriveEncoderTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveSensorlessEstimatorTypeInfo<T>::property_table[] = {
    {"error", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SensorlessEstimatorIntf::get_error(std::declval<T*>()))>>::singleton},
    {"phase", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SensorlessEstimatorIntf::get_phase(std::declval<T*>()))>>::singleton},
    {"pll_pos", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SensorlessEstimatorIntf::get_pll_pos(std::declval<T*>()))>>::singleton},
    {"vel_estimate", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SensorlessEstimatorIntf::get_vel_estimate(std::declval<T*>()))>>::singleton},
    {"config", &ODriveSensorlessEstimatorConfigTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SensorlessEstimatorIntf::get_config(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveSensorlessEstimatorTypeInfo<T> ODriveSensorlessEstimatorTypeInfo<T>::singleton{ODriveSensorlessEstimatorTypeInfo<T>::property_table, sizeof(ODriveSensorlessEstimatorTypeInfo<T>::property_table) / sizeof(ODriveSensorlessEstimatorTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveTrapezoidalTrajectoryTypeInfo<T>::property_table[] = {
    {"config", &ODriveTrapezoidalTrajectoryConfigTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::TrapezoidalTrajectoryIntf::get_config(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveTrapezoidalTrajectoryTypeInfo<T> ODriveTrapezoidalTrajectoryTypeInfo<T>::singleton{ODriveTrapezoidalTrajectoryTypeInfo<T>::property_table, sizeof(ODriveTrapezoidalTrajectoryTypeInfo<T>::property_table) / sizeof(ODriveTrapezoidalTrajectoryTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveEndstopTypeInfo<T>::property_table[] = {
    {"endstop_state", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EndstopIntf::get_endstop_state(std::declval<T*>()))>>::singleton},
    {"config", &ODriveEndstopConfigTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EndstopIntf::get_config(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveEndstopTypeInfo<T> ODriveEndstopTypeInfo<T>::singleton{ODriveEndstopTypeInfo<T>::property_table, sizeof(ODriveEndstopTypeInfo<T>::property_table) / sizeof(ODriveEndstopTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveSystemStatsTypeInfo<T>::property_table[] = {
    {"uptime", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_uptime(std::declval<T*>()))>>::singleton},
    {"min_heap_space", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_min_heap_space(std::declval<T*>()))>>::singleton},
    {"min_stack_space_axis0", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_min_stack_space_axis0(std::declval<T*>()))>>::singleton},
    {"min_stack_space_axis1", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_min_stack_space_axis1(std::declval<T*>()))>>::singleton},
    {"min_stack_space_comms", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_min_stack_space_comms(std::declval<T*>()))>>::singleton},
    {"min_stack_space_usb", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_min_stack_space_usb(std::declval<T*>()))>>::singleton},
    {"min_stack_space_uart", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_min_stack_space_uart(std::declval<T*>()))>>::singleton},
    {"min_stack_space_can", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_min_stack_space_can(std::declval<T*>()))>>::singleton},
    {"min_stack_space_usb_irq", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_min_stack_space_usb_irq(std::declval<T*>()))>>::singleton},
    {"min_stack_space_startup", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_min_stack_space_startup(std::declval<T*>()))>>::singleton},
    {"stack_usage_axis0", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_stack_usage_axis0(std::declval<T*>()))>>::singleton},
    {"stack_usage_axis1", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_stack_usage_axis1(std::declval<T*>()))>>::singleton},
    {"stack_usage_comms", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_stack_usage_comms(std::declval<T*>()))>>::singleton},
    {"stack_usage_usb", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_stack_usage_usb(std::declval<T*>()))>>::singleton},
    {"stack_usage_uart", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_stack_usage_uart(std::declval<T*>()))>>::singleton},
    {"stack_usage_usb_irq", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_stack_usage_usb_irq(std::declval<T*>()))>>::singleton},
    {"stack_usage_startup", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_stack_usage_startup(std::declval<T*>()))>>::singleton},
    {"stack_usage_can", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_stack_usage_can(std::declval<T*>()))>>::singleton},
    {"usb", &ODriveSystemStatsUsbTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_usb(std::declval<T*>()))>>::singleton},
    {"i2c", &ODriveSystemStatsI2CTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_i2c(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveSystemStatsTypeInfo<T> ODriveSystemStatsTypeInfo<T>::singleton{ODriveSystemStatsTypeInfo<T>::property_table, sizeof(ODriveSystemStatsTypeInfo<T>::property_table) / sizeof(ODriveSystemStatsTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveSystemStatsUsbTypeInfo<T>::property_table[] = {
    {"rx_cnt", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::UsbIntf::get_rx_cnt(std::declval<T*>()))>>::singleton},
    {"tx_cnt", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::UsbIntf::get_tx_cnt(std::declval<T*>()))>>::singleton},
    {"tx_overrun_cnt", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::UsbIntf::get_tx_overrun_cnt(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveSystemStatsUsbTypeInfo<T> ODriveSystemStatsUsbTypeInfo<T>::singleton{ODriveSystemStatsUsbTypeInfo<T>::property_table, sizeof(ODriveSystemStatsUsbTypeInfo<T>::property_table) / sizeof(ODriveSystemStatsUsbTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveSystemStatsI2CTypeInfo<T>::property_table[] = {
    {"addr", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::I2CIntf::get_addr(std::declval<T*>()))>>::singleton},
    {"addr_match_cnt", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::I2CIntf::get_addr_match_cnt(std::declval<T*>()))>>::singleton},
    {"rx_cnt", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::I2CIntf::get_rx_cnt(std::declval<T*>()))>>::singleton},
    {"error_cnt", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::I2CIntf::get_error_cnt(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveSystemStatsI2CTypeInfo<T> ODriveSystemStatsI2CTypeInfo<T>::singleton{ODriveSystemStatsI2CTypeInfo<T>::property_table, sizeof(ODriveSystemStatsI2CTypeInfo<T>::property_table) / sizeof(ODriveSystemStatsI2CTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveConfigTypeInfo<T>::property_table[] = {
    {"enable_uart", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_enable_uart(std::declval<T*>()))>>::singleton},
    {"uart_baudrate", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_uart_baudrate(std::declval<T*>()))>>::singleton},
    {"enable_i2c_instead_of_can", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_enable_i2c_instead_of_can(std::declval<T*>()))>>::singleton},
    {"enable_ascii_protocol_on_usb", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_enable_ascii_protocol_on_usb(std::declval<T*>()))>>::singleton},
    {"max_regen_current", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_max_regen_current(std::declval<T*>()))>>::singleton},
    {"brake_resistance", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_brake_resistance(std::declval<T*>()))>>::singleton},
    {"dc_bus_undervoltage_trip_level", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_dc_bus_undervoltage_trip_level(std::declval<T*>()))>>::singleton},
    {"dc_bus_overvoltage_trip_level", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_dc_bus_overvoltage_trip_level(std::declval<T*>()))>>::singleton},
    {"enable_dc_bus_overvoltage_ramp", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_enable_dc_bus_overvoltage_ramp(std::declval<T*>()))>>::singleton},
    {"dc_bus_overvoltage_ramp_start", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_dc_bus_overvoltage_ramp_start(std::declval<T*>()))>>::singleton},
    {"dc_bus_overvoltage_ramp_end", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_dc_bus_overvoltage_ramp_end(std::declval<T*>()))>>::singleton},
    {"dc_max_positive_current", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_dc_max_positive_current(std::declval<T*>()))>>::singleton},
    {"dc_max_negative_current", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_dc_max_negative_current(std::declval<T*>()))>>::singleton},
    {"gpio1_pwm_mapping", &ODriveEndpointTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_gpio1_pwm_mapping(std::declval<T*>()))>>::singleton},
    {"gpio2_pwm_mapping", &ODriveEndpointTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_gpio2_pwm_mapping(std::declval<T*>()))>>::singleton},
    {"gpio3_pwm_mapping", &ODriveEndpointTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_gpio3_pwm_mapping(std::declval<T*>()))>>::singleton},
    {"gpio4_pwm_mapping", &ODriveEndpointTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_gpio4_pwm_mapping(std::declval<T*>()))>>::singleton},
    {"gpio3_analog_mapping", &ODriveEndpointTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_gpio3_analog_mapping(std::declval<T*>()))>>::singleton},
    {"gpio4_analog_mapping", &ODriveEndpointTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_gpio4_analog_mapping(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveConfigTypeInfo<T> ODriveConfigTypeInfo<T>::singleton{ODriveConfigTypeInfo<T>::property_table, sizeof(ODriveConfigTypeInfo<T>::property_table) / sizeof(ODriveConfigTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveCanConfigTypeInfo<T>::property_table[] = {
    {"baud_rate", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::CanIntf::ConfigIntf::get_baud_rate(std::declval<T*>()))>>::singleton},
    {"protocol", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::CanIntf::ConfigIntf::get_protocol(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveCanConfigTypeInfo<T> ODriveCanConfigTypeInfo<T>::singleton{ODriveCanConfigTypeInfo<T>::property_table, sizeof(ODriveCanConfigTypeInfo<T>::property_table) / sizeof(ODriveCanConfigTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveAxisConfigTypeInfo<T>::property_table[] = {
    {"startup_motor_calibration", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_startup_motor_calibration(std::declval<T*>()))>>::singleton},
    {"startup_encoder_index_search", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_startup_encoder_index_search(std::declval<T*>()))>>::singleton},
    {"startup_encoder_offset_calibration", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_startup_encoder_offset_calibration(std::declval<T*>()))>>::singleton},
    {"startup_closed_loop_control", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_startup_closed_loop_control(std::declval<T*>()))>>::singleton},
    {"startup_sensorless_control", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_startup_sensorless_control(std::declval<T*>()))>>::singleton},
    {"startup_homing", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_startup_homing(std::declval<T*>()))>>::singleton},
    {"enable_step_dir", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_enable_step_dir(std::declval<T*>()))>>::singleton},
    {"step_dir_always_on", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_step_dir_always_on(std::declval<T*>()))>>::singleton},
    {"use_enable_pin", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_use_enable_pin(std::declval<T*>()))>>::singleton},
    {"enable_pin_active_low", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_enable_pin_active_low(std::declval<T*>()))>>::singleton},
    {"counts_per_step", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_counts_per_step(std::declval<T*>()))>>::singleton},
    {"watchdog_timeout", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_watchdog_timeout(std::declval<T*>()))>>::singleton},
    {"enable_watchdog", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_enable_watchdog(std::declval<T*>()))>>::singleton},
    {"step_gpio_pin", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_step_gpio_pin(std::declval<T*>()))>>::singleton},
    {"dir_gpio_pin", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_dir_gpio_pin(std::declval<T*>()))>>::singleton},
    {"en_gpio_pin", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_en_gpio_pin(std::declval<T*>()))>>::singleton},
    {"calibration_lockin", &ODriveAxisConfigCalibrationLockinTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_calibration_lockin(std::declval<T*>()))>>::singleton},
    {"sensorless_ramp", &ODriveAxisLockinConfigTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_sensorless_ramp(std::declval<T*>()))>>::singleton},
    {"general_lockin", &ODriveAxisLockinConfigTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_general_lockin(std::declval<T*>()))>>::singleton},
    {"can_node_id", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_can_node_id(std::declval<T*>()))>>::singleton},
    {"can_node_id_extended", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_can_node_id_extended(std::declval<T*>()))>>::singleton},
    {"can_heartbeat_rate_ms", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_can_heartbeat_rate_ms(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveAxisConfigTypeInfo<T> ODriveAxisConfigTypeInfo<T>::singleton{ODriveAxisConfigTypeInfo<T>::property_table, sizeof(ODriveAxisConfigTypeInfo<T>::property_table) / sizeof(ODriveAxisConfigTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveAxisConfigCalibrationLockinTypeInfo<T>::property_table[] = {
    {"current", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_current(std::declval<T*>()))>>::singleton},
    {"ramp_time", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_ramp_time(std::declval<T*>()))>>::singleton},
    {"ramp_distance", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_ramp_distance(std::declval<T*>()))>>::singleton},
    {"accel", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_accel(std::declval<T*>()))>>::singleton},
    {"vel", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_vel(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveAxisConfigCalibrationLockinTypeInfo<T> ODriveAxisConfigCalibrationLockinTypeInfo<T>::singleton{ODriveAxisConfigCalibrationLockinTypeInfo<T>::property_table, sizeof(ODriveAxisConfigCalibrationLockinTypeInfo<T>::property_table) / sizeof(ODriveAxisConfigCalibrationLockinTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveMotorCurrentControlTypeInfo<T>::property_table[] = {
    {"p_gain", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_p_gain(std::declval<T*>()))>>::singleton},
    {"i_gain", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_i_gain(std::declval<T*>()))>>::singleton},
    {"v_current_control_integral_d", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_v_current_control_integral_d(std::declval<T*>()))>>::singleton},
    {"v_current_control_integral_q", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_v_current_control_integral_q(std::declval<T*>()))>>::singleton},
    {"Ibus", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_Ibus(std::declval<T*>()))>>::singleton},
    {"final_v_alpha", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_final_v_alpha(std::declval<T*>()))>>::singleton},
    {"final_v_beta", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_final_v_beta(std::declval<T*>()))>>::singleton},
    {"Id_setpoint", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_Id_setpoint(std::declval<T*>()))>>::singleton},
    {"Iq_setpoint", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_Iq_setpoint(std::declval<T*>()))>>::singleton},
    {"Iq_measured", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_Iq_measured(std::declval<T*>()))>>::singleton},
    {"Id_measured", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_Id_measured(std::declval<T*>()))>>::singleton},
    {"I_measured_report_filter_k", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_I_measured_report_filter_k(std::declval<T*>()))>>::singleton},
    {"max_allowed_current", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_max_allowed_current(std::declval<T*>()))>>::singleton},
    {"overcurrent_trip_level", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_overcurrent_trip_level(std::declval<T*>()))>>::singleton},
    {"acim_rotor_flux", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_acim_rotor_flux(std::declval<T*>()))>>::singleton},
    {"async_phase_vel", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_async_phase_vel(std::declval<T*>()))>>::singleton},
    {"async_phase_offset", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_async_phase_offset(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveMotorCurrentControlTypeInfo<T> ODriveMotorCurrentControlTypeInfo<T>::singleton{ODriveMotorCurrentControlTypeInfo<T>::property_table, sizeof(ODriveMotorCurrentControlTypeInfo<T>::property_table) / sizeof(ODriveMotorCurrentControlTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveMotorGateDriverTypeInfo<T>::property_table[] = {
    {"drv_fault", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::GateDriverIntf::get_drv_fault(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveMotorGateDriverTypeInfo<T> ODriveMotorGateDriverTypeInfo<T>::singleton{ODriveMotorGateDriverTypeInfo<T>::property_table, sizeof(ODriveMotorGateDriverTypeInfo<T>::property_table) / sizeof(ODriveMotorGateDriverTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveMotorTimingLogTypeInfo<T>::property_table[] = {
    {"general", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::TimingLogIntf::get_general(std::declval<T*>()))>>::singleton},
    {"adc_cb_i", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::TimingLogIntf::get_adc_cb_i(std::declval<T*>()))>>::singleton},
    {"adc_cb_dc", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::TimingLogIntf::get_adc_cb_dc(std::declval<T*>()))>>::singleton},
    {"meas_r", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::TimingLogIntf::get_meas_r(std::declval<T*>()))>>::singleton},
    {"meas_l", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::TimingLogIntf::get_meas_l(std::declval<T*>()))>>::singleton},
    {"enc_calib", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::TimingLogIntf::get_enc_calib(std::declval<T*>()))>>::singleton},
    {"idx_search", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::TimingLogIntf::get_idx_search(std::declval<T*>()))>>::singleton},
    {"foc_voltage", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::TimingLogIntf::get_foc_voltage(std::declval<T*>()))>>::singleton},
    {"foc_current", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::TimingLogIntf::get_foc_current(std::declval<T*>()))>>::singleton},
    {"spi_start", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::TimingLogIntf::get_spi_start(std::declval<T*>()))>>::singleton},
    {"sample_now", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::TimingLogIntf::get_sample_now(std::declval<T*>()))>>::singleton},
    {"spi_end", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::TimingLogIntf::get_spi_end(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveMotorTimingLogTypeInfo<T> ODriveMotorTimingLogTypeInfo<T>::singleton{ODriveMotorTimingLogTypeInfo<T>::property_table, sizeof(ODriveMotorTimingLogTypeInfo<T>::property_table) / sizeof(ODriveMotorTimingLogTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveMotorConfigTypeInfo<T>::property_table[] = {
    {"pre_calibrated", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_pre_calibrated(std::declval<T*>()))>>::singleton},
    {"pole_pairs", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_pole_pairs(std::declval<T*>()))>>::singleton},
    {"calibration_current", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_calibration_current(std::declval<T*>()))>>::singleton},
    {"resistance_calib_max_voltage", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_resistance_calib_max_voltage(std::declval<T*>()))>>::singleton},
    {"phase_inductance", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_phase_inductance(std::declval<T*>()))>>::singleton},
    {"phase_resistance", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_phase_resistance(std::declval<T*>()))>>::singleton},
    {"torque_constant", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_torque_constant(std::declval<T*>()))>>::singleton},
    {"direction", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_direction(std::declval<T*>()))>>::singleton},
    {"motor_type", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_motor_type(std::declval<T*>()))>>::singleton},
    {"current_lim", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_current_lim(std::declval<T*>()))>>::singleton},
    {"current_lim_margin", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_current_lim_margin(std::declval<T*>()))>>::singleton},
    {"torque_lim", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_torque_lim(std::declval<T*>()))>>::singleton},
    {"inverter_temp_limit_lower", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_inverter_temp_limit_lower(std::declval<T*>()))>>::singleton},
    {"inverter_temp_limit_upper", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_inverter_temp_limit_upper(std::declval<T*>()))>>::singleton},
    {"requested_current_range", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_requested_current_range(std::declval<T*>()))>>::singleton},
    {"current_control_bandwidth", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_current_control_bandwidth(std::declval<T*>()))>>::singleton},
    {"acim_slip_velocity", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_acim_slip_velocity(std::declval<T*>()))>>::singleton},
    {"acim_gain_min_flux", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_acim_gain_min_flux(std::declval<T*>()))>>::singleton},
    {"acim_autoflux_min_Id", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_acim_autoflux_min_Id(std::declval<T*>()))>>::singleton},
    {"acim_autoflux_enable", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_acim_autoflux_enable(std::declval<T*>()))>>::singleton},
    {"acim_autoflux_attack_gain", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_acim_autoflux_attack_gain(std::declval<T*>()))>>::singleton},
    {"acim_autoflux_decay_gain", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_acim_autoflux_decay_gain(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveMotorConfigTypeInfo<T> ODriveMotorConfigTypeInfo<T>::singleton{ODriveMotorConfigTypeInfo<T>::property_table, sizeof(ODriveMotorConfigTypeInfo<T>::property_table) / sizeof(ODriveMotorConfigTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveControllerConfigTypeInfo<T>::property_table[] = {
    {"gain_scheduling_width", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_gain_scheduling_width(std::declval<T*>()))>>::singleton},
    {"enable_vel_limit", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_enable_vel_limit(std::declval<T*>()))>>::singleton},
    {"enable_current_mode_vel_limit", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_enable_current_mode_vel_limit(std::declval<T*>()))>>::singleton},
    {"enable_gain_scheduling", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_enable_gain_scheduling(std::declval<T*>()))>>::singleton},
    {"enable_overspeed_error", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_enable_overspeed_error(std::declval<T*>()))>>::singleton},
    {"control_mode", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_control_mode(std::declval<T*>()))>>::singleton},
    {"input_mode", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_input_mode(std::declval<T*>()))>>::singleton},
    {"pos_gain", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_pos_gain(std::declval<T*>()))>>::singleton},
    {"vel_gain", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_vel_gain(std::declval<T*>()))>>::singleton},
    {"vel_integrator_gain", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_vel_integrator_gain(std::declval<T*>()))>>::singleton},
    {"vel_limit", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_vel_limit(std::declval<T*>()))>>::singleton},
    {"vel_limit_tolerance", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_vel_limit_tolerance(std::declval<T*>()))>>::singleton},
    {"vel_ramp_rate", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_vel_ramp_rate(std::declval<T*>()))>>::singleton},
    {"torque_ramp_rate", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_torque_ramp_rate(std::declval<T*>()))>>::singleton},
    {"homing_speed", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_homing_speed(std::declval<T*>()))>>::singleton},
    {"inertia", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_inertia(std::declval<T*>()))>>::singleton},
    {"axis_to_mirror", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_axis_to_mirror(std::declval<T*>()))>>::singleton},
    {"mirror_ratio", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_mirror_ratio(std::declval<T*>()))>>::singleton},
    {"load_encoder_axis", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_load_encoder_axis(std::declval<T*>()))>>::singleton},
    {"input_filter_bandwidth", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_input_filter_bandwidth(std::declval<T*>()))>>::singleton},
    {"anticogging", &ODriveControllerConfigAnticoggingTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_anticogging(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveControllerConfigTypeInfo<T> ODriveControllerConfigTypeInfo<T>::singleton{ODriveControllerConfigTypeInfo<T>::property_table, sizeof(ODriveControllerConfigTypeInfo<T>::property_table) / sizeof(ODriveControllerConfigTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveControllerConfigAnticoggingTypeInfo<T>::property_table[] = {
    {"index", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_index(std::declval<T*>()))>>::singleton},
    {"pre_calibrated", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_pre_calibrated(std::declval<T*>()))>>::singleton},
    {"calib_anticogging", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_calib_anticogging(std::declval<T*>()))>>::singleton},
    {"calib_pos_threshold", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_calib_pos_threshold(std::declval<T*>()))>>::singleton},
    {"calib_vel_threshold", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_calib_vel_threshold(std::declval<T*>()))>>::singleton},
    {"cogging_ratio", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_cogging_ratio(std::declval<T*>()))>>::singleton},
    {"anticogging_enabled", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_anticogging_enabled(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveControllerConfigAnticoggingTypeInfo<T> ODriveControllerConfigAnticoggingTypeInfo<T>::singleton{ODriveControllerConfigAnticoggingTypeInfo<T>::property_table, sizeof(ODriveControllerConfigAnticoggingTypeInfo<T>::property_table) / sizeof(ODriveControllerConfigAnticoggingTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveEncoderConfigTypeInfo<T>::property_table[] = {
    {"mode", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_mode(std::declval<T*>()))>>::singleton},
    {"use_index", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_use_index(std::declval<T*>()))>>::singleton},
    {"find_idx_on_lockin_only", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_find_idx_on_lockin_only(std::declval<T*>()))>>::singleton},
    {"abs_spi_cs_gpio_pin", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_abs_spi_cs_gpio_pin(std::declval<T*>()))>>::singleton},
    {"zero_count_on_find_idx", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_zero_count_on_find_idx(std::declval<T*>()))>>::singleton},
    {"cpr", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_cpr(std::declval<T*>()))>>::singleton},
    {"offset", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_offset(std::declval<T*>()))>>::singleton},
    {"pre_calibrated", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_pre_calibrated(std::declval<T*>()))>>::singleton},
    {"offset_float", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_offset_float(std::declval<T*>()))>>::singleton},
    {"enable_phase_interpolation", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_enable_phase_interpolation(std::declval<T*>()))>>::singleton},
    {"bandwidth", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_bandwidth(std::declval<T*>()))>>::singleton},
    {"calib_range", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_calib_range(std::declval<T*>()))>>::singleton},
    {"calib_scan_distance", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_calib_scan_distance(std::declval<T*>()))>>::singleton},
    {"calib_scan_omega", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_calib_scan_omega(std::declval<T*>()))>>::singleton},
    {"idx_search_unidirectional", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_idx_search_unidirectional(std::declval<T*>()))>>::singleton},
    {"ignore_illegal_hall_state", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_ignore_illegal_hall_state(std::declval<T*>()))>>::singleton},
    {"sincos_gpio_pin_sin", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_sincos_gpio_pin_sin(std::declval<T*>()))>>::singleton},
    {"sincos_gpio_pin_cos", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_sincos_gpio_pin_cos(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveEncoderConfigTypeInfo<T> ODriveEncoderConfigTypeInfo<T>::singleton{ODriveEncoderConfigTypeInfo<T>::property_table, sizeof(ODriveEncoderConfigTypeInfo<T>::property_table) / sizeof(ODriveEncoderConfigTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveSensorlessEstimatorConfigTypeInfo<T>::property_table[] = {
    {"observer_gain", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SensorlessEstimatorIntf::ConfigIntf::get_observer_gain(std::declval<T*>()))>>::singleton},
    {"pll_bandwidth", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SensorlessEstimatorIntf::ConfigIntf::get_pll_bandwidth(std::declval<T*>()))>>::singleton},
    {"pm_flux_linkage", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SensorlessEstimatorIntf::ConfigIntf::get_pm_flux_linkage(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveSensorlessEstimatorConfigTypeInfo<T> ODriveSensorlessEstimatorConfigTypeInfo<T>::singleton{ODriveSensorlessEstimatorConfigTypeInfo<T>::property_table, sizeof(ODriveSensorlessEstimatorConfigTypeInfo<T>::property_table) / sizeof(ODriveSensorlessEstimatorConfigTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveTrapezoidalTrajectoryConfigTypeInfo<T>::property_table[] = {
    {"vel_limit", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::TrapezoidalTrajectoryIntf::ConfigIntf::get_vel_limit(std::declval<T*>()))>>::singleton},
    {"accel_limit", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::TrapezoidalTrajectoryIntf::ConfigIntf::get_accel_limit(std::declval<T*>()))>>::singleton},
    {"decel_limit", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::TrapezoidalTrajectoryIntf::ConfigIntf::get_decel_limit(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveTrapezoidalTrajectoryConfigTypeInfo<T> ODriveTrapezoidalTrajectoryConfigTypeInfo<T>::singleton{ODriveTrapezoidalTrajectoryConfigTypeInfo<T>::property_table, sizeof(ODriveTrapezoidalTrajectoryConfigTypeInfo<T>::property_table) / sizeof(ODriveTrapezoidalTrajectoryConfigTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveEndstopConfigTypeInfo<T>::property_table[] = {
    {"gpio_num", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EndstopIntf::ConfigIntf::get_gpio_num(std::declval<T*>()))>>::singleton},
    {"enabled", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EndstopIntf::ConfigIntf::get_enabled(std::declval<T*>()))>>::singleton},
    {"offset", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EndstopIntf::ConfigIntf::get_offset(std::declval<T*>()))>>::singleton},
    {"is_active_high", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EndstopIntf::ConfigIntf::get_is_active_high(std::declval<T*>()))>>::singleton},
    {"pullup", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EndstopIntf::ConfigIntf::get_pullup(std::declval<T*>()))>>::singleton},
    {"debounce_ms", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EndstopIntf::ConfigIntf::get_debounce_ms(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveEndstopConfigTypeInfo<T> ODriveEndstopConfigTypeInfo<T>::singleton{ODriveEndstopConfigTypeInfo<T>::property_table, sizeof(ODriveEndstopConfigTypeInfo<T>::property_table) / sizeof(ODriveEndstopConfigTypeInfo<T>::property_table[0])};



#pragma GCC pop_options